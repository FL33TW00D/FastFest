<!doctype html>
<head>
    <meta charset="utf-8">
    <title>Festify+</title>
    <meta name="description" content="Which festival should I go to?">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Was making an annoying error so got rid of webmanifest -->
    <!-- <link rel="manifest" href="site.webmanifest"> -->
    <link rel="apple-touch-icon" href="icon.png">
    <!-- Place favicon.ico in the root directory -->

    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link type="text/css" rel="stylesheet" href="//unpkg.com/bootstrap-vue@latest/dist/bootstrap-vue.min.css" />
    <link href="https://fonts.googleapis.com/css?family=Montserrat&display=swap" rel="stylesheet"> 
    <script src="https://kit.fontawesome.com/4dfe369057.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="//unpkg.com/bootstrap-vue@latest/dist/bootstrap-vue.min.js"></script>
</head>
<body>
<div id="app" class="p-2" style="height:100vh; width:100vw; color:white; background-color:#191414; font-family:'Montserrat', sans-serif;">
    <span class="px-3" style="color:#1DB954; font-weight:600; font-size: 60px;">Fastfest</span>
    <!-- <div class="container">
        <div id="login">
          <h1>Log in with spotify to find the best festival for you!</h1>
          <span style="border-radius: 20px !important;">
                <a href="http://localhost:3000/api/login" class="btn btn-success" role="button" style="border-radius: 18px;margin: 10px;">
                    <i class="fab fa-spotify fa-lg"></i>
                    Login to Spotify
                </a>
            </span>
        </div>
        <div id = "testing_buttons">
            <button @click="populateFestivals">Populate Festivals</button>
            <button @click="populateArtists">Populate Artists</button>
            <button @click="findBestMatch">Find Best Match</button>
        </div>
        <div id="loggedin">
          <div id="user-profile">
          </div>
          <div id="oauth">
          </div>
        </div>
    </div> -->
    <div class="row mx-5">
        <div class="col-8">
            <h1>Log in with spotify to find the best festival for you!</h1>
            <div id = "testing_buttons">
                <button @click="populateFestivals">Populate Festivals</button>
                <button @click="populateArtists">Populate Artists</button>
                <button @click="findBestMatch">Find Best Match</button>
            </div>
        </div>
        <div class="col-4">
            <div id="login">
                <div><span style="height: 300px; width: 300px; background-color: #bbb; border-radius: 50%; display: inline-block;"></span></div>
                <div>
                    <span style="border-radius: 20px !important;">
                        <a href="http://localhost:3000/api/login" class="btn btn-success" role="button" style="border-radius: 18px;margin: 10px;">
                            <i class="fab fa-spotify fa-lg"></i>
                            Login to Spotify
                        </a>
                    </span>
                </div>
            </div>
        </div>
    </div>
</div>
</body>

<script>
let app = new Vue({
    el: '#app',
    data() {
        return {
            authenticated: false,
            festivals: [],
            scoreMap: new Map(),
            shortMap: new Map(),
            mediumMap: new Map(),
            longMap: new Map(),
            nameMap: new Map()
        }
    },
    methods: {
        getHashParams(){
            var hashParams = {};
          var e, r = /([^&;=]+)=?([^&;]*)/g,
              q = window.location.hash.substring(1);
          while ( e = r.exec(q)) {
             hashParams[e[1]] = decodeURIComponent(e[2]);
          }
          return hashParams;
        },

        scoringFunction(position, mapType){
            let scalingFactor = 0.05;
            let score = (100/Math.pow(2,(position * scalingFactor)));
            return score;
        },

        populateScoreMap(){
            this.mediumMap.forEach((value, key) => {
                this.scoreMap.set(key.toLowerCase(), this.scoringFunction(value));
                this.nameMap.set(key.toLowerCase(), key);
            });

            this.longMap.forEach((value, key) => {
                if (!this.scoreMap.has(key.toLowerCase())) {
                    this.scoreMap.set(key.toLowerCase(), this.scoringFunction(value));
                    this.nameMap.set(key.toLowerCase(), key);
                }
                else if (this.scoreMap.get(key.toLowerCase()) < this.scoringFunction(value) * 4/5) {
                    this.scoreMap.set(key.toLowerCase(), this.scoringFunction(value) * 4/5);
                } 
            });
            
            console.log(this.scoreMap);
        },

        async populateArtists(){
            console.log('POPULATING ARTISTS');
        //Authentication headers
            var headers = {  
                method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + this.getHashParams().access_token
                    },
                }
            // Parameters: Type: Num Entities to return, max 50.
                        // Offset: The index of the first entity to return
                        //Time Range: Longterm(Years), Mediumterm (6months), shortterm (4weeks)
            let artists = [];
            let rank = 0;
            await fetch('https://api.spotify.com/v1/me/top/artists?time_range=medium_term&limit=49', headers)
                .then(response => response.json())
                .then((data) => {
                    console.log(data);
                    for (let artist in data.items) if (!this.mediumMap.has(data.items[artist].name)) this.mediumMap.set(data.items[artist].name, rank++);
                });
            await fetch('https://api.spotify.com/v1/me/top/artists?time_range=medium_term&limit=50&offset=49', headers)
                .then(response => response.json())
                .then((data) => {
                    console.log(data);
                    for (let artist in data.items) if (!this.mediumMap.has(data.items[artist].name)) this.mediumMap.set(data.items[artist].name, rank++);
                });
            
            rank = 0;
            await fetch('https://api.spotify.com/v1/me/top/artists?time_range=long_term&limit=49', headers)
                .then(response => response.json())
                .then((data) => {
                    console.log(data);
                    for (let artist in data.items) if (!this.longMap.has(data.items[artist].name)) this.longMap.set(data.items[artist].name, rank++);
                });
            await fetch('https://api.spotify.com/v1/me/top/artists?time_range=long_term&limit=50&offset=49', headers)
                .then(response => response.json())
                .then((data) => {
                    //Loading artists into a simple array
                    console.log(data);
                    for (let artist in data.items) if (!this.longMap.has(data.items[artist].name)) this.longMap.set(data.items[artist].name, rank++);
                });

            console.log(this.mediumMap);
            console.log(this.longMap);
        },


        async populateFestivals(){
            console.log('POPULATING FESTIVALS');
            let festivals = [];
            let pages = 0;
            await fetch('http://www.skiddle.com/api/v1/events/search/?api_key=62a2932a3c0079d4f2d0dd00abfade5f&eventcode=FEST&description=1&order=goingto&limit=100')
                .then(response => response.json())
                .then(data => {
                    console.log(data);
                    pages = Math.ceil(data.totalcount / 100);
                    festivals.push.apply(festivals, data.results);
                });

            let base = 100;
            for (let i = 1; i < pages; i++){
                await fetch(`http://www.skiddle.com/api/v1/events/search/?api_key=62a2932a3c0079d4f2d0dd00abfade5f&eventcode=FEST&description=1&order=goingto&limit=100&offset=${base}`)
                    .then(response => response.json())
                    .then(data => {
                        festivals.push.apply(festivals, data.results);
                    });
                base += 100;
            }
            this.festivals = festivals;
            console.log("Done");
        },
        findBestMatch(){
            let matches = [];
            this.populateScoreMap();
            let bestMatch = {name : "", score: Number.MIN_VALUE, matchedArtists: []};
            for(var fest of this.festivals){
                let currentMatch = {name : fest.eventname, score: 0, matchedArtists: [], artists: []};
                for(var art of fest.artists){
                    currentMatch.artists.push(art.name);
                    if(this.scoreMap.has(art.name.toLowerCase())){
                        currentMatch.score += this.scoreMap.get(art.name.toLowerCase());
                        currentMatch.matchedArtists.push(art.name);
                    }
                }
                if(currentMatch.score > 0 && typeof matches.find((element) => {return element.name === fest.eventname;}) === "undefined"){
                    matches.push(currentMatch);
                    if(currentMatch.score > bestMatch.score){
                        bestMatch = currentMatch;
                    }
                }
            }

            console.log(matches.sort((a, b) => (a.score < b.score) ? 1 : -1));
            console.log(bestMatch);
        }
    }
});
</script>
